<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>Hasql: what&#39;s coming</title>
  <style type="text/css">
    @import url(https://fonts.googleapis.com/css?family=Exo+2:100,200,400,700|Open+Sans:300|Source+Code+Pro:300&subset=latin,cyrillic);

/*
LAYOUT
------
*/

* {
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
}

body, html, h1, h2, h3, h4, ol, ul {
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
}

h2 {
  text-align: center;
}

h3 {
  border-bottom: 1px solid;
  position: absolute;
  top: 0;
  width: 100%;
  left: 0;
  padding: 10px 40px;
  z-index: 10;
}

.author h3 {
  position: relative;
}

h4 {
  margin-bottom: 10px;
}

.center {
  text-align: center;
}

img {
  margin: 0 auto;
  display: block;
}

/*
  slides styling
 */
body, html, .slide {
  width: 100%;
  height: 100%;
}

.slide {
  display: flex;
  align-items: center;
  padding: 0 40px;
  opacity: 1;
  visibility: visible;
  position: absolute;
  top: 0;
  left: 0;
  -webkit-transition: opacity 0.3s ease, visibility 0.3s ease;  
  -moz-transition:    opacity 0.3s ease, visibility 0.3s ease;
  -ms-transition:     opacity 0.3s ease, visibility 0.3s ease; 
  -o-transition:      opacity 0.3s ease, visibility 0.3s ease;
  transition:         opacity 0.3s ease, visibility 0.3s ease;
  overflow: hidden;
}

.slide-content {
  flex-basis: 100%;
}

.slide.hidden {
  opacity: 0;
  visibility: hidden;
}

ul, ol {
  padding: 0 40px;
  margin-bottom: 20px;
  margin-top: 20px;
}

.progress-bar {
  position: fixed;
  top: 0px;
  left: 0px;
  height: 5px;
  z-index: 100;
  -webkit-transition: width 0.3s ease;  
  -moz-transition:    width 0.3s ease;
  -ms-transition:     width 0.3s ease; 
  -o-transition:      width 0.3s ease;
  transition:         width 0.3s ease;
}

code, pre {
  border: 1px solid;
  border-radius: 3px;
  overflow: auto;
  padding: 6px 10px;
}

code {
  padding: 0 5px;
}

pre > code {
  margin: 0; padding: 0;
  border: none;
  background: transparent;
}

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
}


/*
FONTS
-----
*/

body, html {
  font-family: 'Exo 2', sans-serif;
  font-weight: 100;
  font-size: 24px;
  line-height: 30px;
}

h1, h2, h3, h4 {
  font-family: 'Exo 2', sans-serif;
}

h1 {
  font-weight: 400;
  font-size: 60px;
  line-height: 70px;
}

h2 {
  font-size: 50px;
  line-height: 60px;
  font-weight: 100;
}

h3 {
  font-size: 44px;
  line-height: 54px;
  font-weight: 100;
}

h4 {
  font-size: 38px;
  line-height: 48px;
  font-weight: 400;
}

a {
  text-decoration: none;
  font-weight: 400;
}

p, ol, ul {
  font-size: 34px;
  line-height: 44px;
}

strong {
  font-weight: 400;
}

code, pre {
  font-family: 'Source Code Pro';
  font-weight: 300;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}

.author h3 {
  font-size: 34px;
}


/*
COLORS
------

A one stop shop for changing colors.

The current color scheme ref:
https://coolors.co/f9c866-f7f7f7-6d6565-9cdefc-111214
https://coolors.co/ffc654-f7f7f7-ce1e1e-9cdefc-111214
https://coolors.co/ffc654-f7f7f7-ce4685-9cdefc-111214
*/

body, html, ol, ul { color: #F7F7F7; }
h1, h2, h3, h4, h5, h6 { color: #9CDEFC; }
.slide { background-color: #000; }
code, pre { color: #F7F7F7; border-color: #F7F7F7; background-color: #111214; }
.progress-bar { background-color: #89BCD3; }
a { color: #F7F7F7; }
a:hover { color: #F7F7F7; }
b, strong { color: #F9C866; }
h3 { border-bottom-color: #fff background-color: #F7F7F7; }


/*
HLJS COLORS
===========
*/
.hljs {
  background: #111214;
}

.hljs-built_in,
.hljs-selector-tag,
.hljs-section,
.hljs-link {
  color: #9CDEFC;
}

.hljs-keyword {
  color: #CE1E1E;
}

.hljs,
.hljs-subst {
  color: #f8f8f2;
}

.hljs-title {
  color: #9CDEFC;
}

.hljs-string,
.hljs-meta,
.hljs-name,
.hljs-type,
.hljs-attr,
.hljs-symbol
.hljs-bullet,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #FFC654;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion {
  color: #ce4685;
}

.hljs-literal,
.hljs-number {
  color: #B546CE;
}


  </style>
</head>
<body>
  <div class="progress-bar"></div>
    <div class="slide" id="slide-1">
    <section class="slide-content">
      <h1 id="hasql-what-s-coming">Hasql: what&#39;s coming</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-2">
    <section class="slide-content">
      <h1 id="about-hasql">About Hasql</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-3">
    <section class="slide-content">
      <h1 id="the-fastest-postgres-driver-in-haskell">The fastest Postgres driver in Haskell</h1>
<!-- 
Hasql is known as the fastest Postgres driver in Haskell.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-4">
    <section class="slide-content">
      <h1 id="the-fastest-postgres-driver-in-haskell">The fastest Postgres driver in Haskell</h1>
<ul>
<li>Faster than &quot;postgresql-simple&quot; by &gt;= 2x</li>
</ul>
<!-- 
For instance, in most benchmarks it's faster than "postgresql-simple" by at least a factor of 2.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-5">
    <section class="slide-content">
      <h1 id="the-fastest-postgres-driver-in-haskell">The fastest Postgres driver in Haskell</h1>
<ul>
<li>Faster than &quot;postgresql-simple&quot; by &gt;= 2x</li>
<li>Uses parametric queries</li>
</ul>
<!--
Uses parametric queries instead of injecting the values into SQL, like "postgresql-simple" does. Naturally this gives a performance boost.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-6">
    <section class="slide-content">
      <h1 id="the-fastest-postgres-driver-in-haskell">The fastest Postgres driver in Haskell</h1>
<ul>
<li>Faster than &quot;postgresql-simple&quot; by &gt;= 2x</li>
<li>Uses parametric queries</li>
<li>Uses binary format for values</li>
</ul>
<!--
It uses a binary encoding of values for communication with the backend.

Naturally, binary format is way faster than the human-readable textual format.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-7">
    <section class="slide-content">
      <h1 id="mapping-api">Mapping API</h1>
<!--
Another interesting peculiarity of Hasql is the approach taken to the problem of the mapping API.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-8">
    <section class="slide-content">
      <h2 id="composable-abstractions">Composable abstractions</h2>
<!-- 
The key idea behind its design is that all kinds of complex real world effects can be composed using the category theory abstractions. It is not at all limited to the pure stuff we're used to associating the mathematical abstractions with. It merely just takes a proper approach to problem isolation to get that property.

And it turns out, that even dealing with a low-level highly stateful C library, which Hasql has to do, is no exception to that rule.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-9">
    <section class="slide-content">
      <h2 id="layers-of-codecs">Layers of codecs</h2>
<!--
Most database libraries obscure the problem of mapping by making it an extensional feature of a larger abstraction, instead of treating it as an isolated abstraction.

In Hasql every step of the mapping process is isolated into a dedicated abstraction.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-10">
    <section class="slide-content">
      <h2 id="database-rows-haskell-data">Database Rows -&gt; Haskell data</h2>
<pre><code class="lang-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">"name"</span>, <span class="hljs-string">"birthday"</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">"persons"</span></code></pre>
<p>:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)</code></pre>
<!-- 
For instance, turning database result rows into haskell data is an isolated problem.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-11">
    <section class="slide-content">
      <h2 id="packing-rows">Packing rows</h2>
<pre><code class="lang-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">"name"</span>, <span class="hljs-string">"birthday"</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">"persons"</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span></code></pre>
<p>:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)</code></pre>
<p>or</p>
<pre><code class="lang-haskell"><span class="hljs-type">Maybe</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)</code></pre>
<p>?</p>
<!-- 
The choice of a proper container for the result rows is an isolated problem.

Here you can see an example, where Maybe is clearly a better choice.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-12">
    <section class="slide-content">
      <h2 id="not-always-rows">Not always rows</h2>
<pre><code class="lang-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">FROM</span> ...</code></pre>
<p>:</p>
<pre><code class="lang-haskell"><span class="hljs-type">Int64</span></code></pre>
<!-- 
The results can also not always be rows as is the case in this example.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-13">
    <section class="slide-content">
      <h2 id="intuition">Intuition</h2>
<p>Every isolated problem deserves an isolated abstraction!</p>
<!-- 
So the approach taken in this library has this intuition. The result of that is that every abstraction introduced has it's own set of proper category theory typeclass instances and composes cleanly.

However a lot of developers tend to have a very wrong intuition:
they decide whether something deserves an isolated abstraction based on the subjective size of the problem.

This is why we don't see granularly decomposed APIs all that often.

And this is why we're used to Real World applications not having much to do with category theory and not being composable all that much.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-14">
    <section class="slide-content">
      <h1 id="the-new-version">The new version</h1>
<!-- 
The things that I've mentioned so far concern all versions of Hasql and are the basic principles behind the design of its API.

Today I'm gonna be talking about a new version of the library. However the new version is still in the works. It's undergoing performance optimization. Benchmarking, profiling and, you know, that sort of tough business.

However it already has the core functionality implemented. At least enough of it to prove that it actually works the way it should.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-15">
    <section class="slide-content">
      <h1 id="distribution">Distribution</h1>
<!-- 
The new version is already distributed. So you can play around with it.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-16">
    <section class="slide-content">
      <h1 id="distribution">Distribution</h1>
<ul>
<li>The new devolopment - <code>0.20.*</code></li>
<li>The battle-tested old version - <code>1.*</code></li>
</ul>
<!--
However since the new version is still not ready for a production release, I came up with this strange versioning scheme. Essentially I keep the experimental ongoing development in the 0-prefixed space.

Thus I get both benefits: I get to make the intermediate releases which are not ready for production, and I get to state clearly, which version is stable.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-17">
    <section class="slide-content">
      <h1 id="what-s-new-">What&#39;s new?</h1>
<!-- 
So what's new in this new version? Why would I want to change anything in a library, which already is in the leading position?

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-18">
    <section class="slide-content">
      <h1 id="postgres">Postgres</h1>
<!-- 
To answer that let's cover a few facts about Postgres.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-19">
    <section class="slide-content">
      <h2 id="postgres">Postgres</h2>
<ul>
<li>Default SQL DB</li>
</ul>
<!-- 
It is the de facto default choice for an SQL database.
It's fast, it's featureful and it's typed.
And it's supported by all kinds of services including Amazon.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-20">
    <section class="slide-content">
      <h2 id="postgres">Postgres</h2>
<ul>
<li>Default SQL DB</li>
<li>&quot;libpq&quot; is the basis for most drivers</li>
</ul>
<!-- 
The absolute majority of drivers for all languages are based on the low-level C library named "libpq".
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-21">
    <section class="slide-content">
      <h2 id="postgres">Postgres</h2>
<ul>
<li>Default SQL DB</li>
<li>&quot;libpq&quot; is the basis for most drivers</li>
<li>&quot;libpq&quot; - low quality library</li>
</ul>
<!-- 
Besides being low level that library is also of low quality. It comes with several bad design decisions, which I'll explain in detail in the coming slides.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-22">
    <section class="slide-content">
      <h2 id="postgres">Postgres</h2>
<ul>
<li>Default SQL DB</li>
<li>&quot;libpq&quot; is the basis for most drivers</li>
<li>&quot;libpq&quot; - low quality library</li>
<li><strong>&quot;hasql&quot; can beat &quot;libpq&quot;!</strong></li>
</ul>
<!-- 
The low quality of "libpq" leaves room for competition.

This means that avoiding the mistakes of "libpq" can make the competing library faster. And it turns out that it's not just a hypothesis. I already have some benchmarks, where Hasql beats "libpq" in certain scenarios! Not in all scenarios yet, but I'm getting there.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-23">
    <section class="slide-content">
      <h1 id="what-s-wrong-with-libpq-">What&#39;s wrong with &quot;libpq&quot;?</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-24">
    <section class="slide-content">
      <h2 id="what-s-wrong-with-libpq-">What&#39;s wrong with &quot;libpq&quot;?</h2>
<ul>
<li>No streaming result processing</li>
</ul>
<!-- 
It doesn't let you start processing the result while you're still receiving it.

Imagine fetching a result with thousands of rows. You'll have to first fetch it all into memory, and only after that will you be able to process it!

Only recently have they introduced a workaround for that, but in the end it works slower than without it.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-25">
    <section class="slide-content">
      <h2 id="what-s-wrong-with-libpq-">What&#39;s wrong with &quot;libpq&quot;?</h2>
<ul>
<li>No streaming result processing</li>
<li>No pipelining</li>
</ul>
<!-- 
For those who don't know, let me explain what pipelining is
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-26">
    <section class="slide-content">
      <h2 id="pipelining">Pipelining</h2>
<p><img src="2.png" width="75%" height="75%"/></p>
<!-- 
This slide compares two models of communication between a client and a server.

To the left you can see a synchronous model, where the client always waits for the server to respond before issuing a new request.

To the right you can see an asynchronous (or pipelining) model, where the client keeps sending the requests without waiting for the results to arrive.

You can easily see that the Async model requires lesser time.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-27">
    <section class="slide-content">
      <h2 id="an-opportunity">An opportunity</h2>
<ul>
<li>&quot;libpq&quot; doesn&#39;t support pipelining</li>
<li>The protocol does</li>
</ul>
<!-- 
"libpq" does not let you use the asynchronous communication model.

But the protocol does!

This gives us a great opportunity!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-28">
    <section class="slide-content">
      <h1 id="new-hasql">New Hasql</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-29">
    <section class="slide-content">
      <h2 id="new-hasql">New Hasql</h2>
<ul>
<li>Directly implements the binary protocol</li>
</ul>
<!-- 
This is why it's been decided to reimplement Hasql to directly use the binary protocol for communication with the server.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-30">
    <section class="slide-content">
      <h2 id="new-hasql">New Hasql</h2>
<ul>
<li>Directly implements the binary protocol</li>
<li>No &quot;libpq&quot;</li>
</ul>
<!-- 
And get rid of the "libpq" dependency completely and hence of all of the constraints it lays upon its users.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-31">
    <section class="slide-content">
      <h2 id="new-hasql">New Hasql</h2>
<ul>
<li>Directly implements the binary protocol</li>
<li>No &quot;libpq&quot;</li>
<li><strong>Supports streaming result processing</strong></li>
</ul>
<!-- 
And voila! New Hasql supports streaming result processing.
I.e., you can easily fetch and process millions of rows without wasting memory!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-32">
    <section class="slide-content">
      <h2 id="new-hasql">New Hasql</h2>
<ul>
<li>Directly implements the binary protocol</li>
<li>No &quot;libpq&quot;</li>
<li><strong>Supports streaming result processing</strong></li>
<li><strong>Supports pipelining</strong></li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-33">
    <section class="slide-content">
      <h1 id="api">API</h1>
<!-- 
Let me give you a birds eye view on the API of the library.

And please notice that it didn't change drastically. So most of the concepts apply to all versions of Hasql. 

So just relax and absorb :)
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-34">
    <section class="slide-content">
      <h1 id="io">IO</h1>
<!--
First we have IO with the whole universe of operations you can perform in it. And we add a few new ones to it:
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-35">
    <section class="slide-content">
      <h2 id="io">IO</h2>
<ul>
<li><code>Hasql.Connection.open</code> - open a connection to the DB</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-36">
    <section class="slide-content">
      <h2 id="io">IO</h2>
<ul>
<li><code>Hasql.Connection.open</code> - open a connection to the DB</li>
<li><code>Hasql.Connection.close</code> - close it</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-37">
    <section class="slide-content">
      <h2 id="io">IO</h2>
<ul>
<li><code>Hasql.Connection.open</code> - open a connection to the DB</li>
<li><code>Hasql.Connection.close</code> - close it</li>
<li><code>Hasql.Connection.session</code> - execute the <code>Session</code> abstraction</li>
</ul>
<!-- 
IOW, the library only lets us do those three simple things in IO. The rest is controlled by the abstractions from API.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-38">
    <section class="slide-content">
      <h1 id="session">Session</h1>
<!--
Then comes Session
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-39">
    <section class="slide-content">
      <h2 id="session">Session</h2>
<p>Is an abstraction over the connection and error</p>
<!-- 
Session is an abstraction over the database connection and the errors that can appear during the communication with it.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-40">
    <section class="slide-content">
      <h2 id="session">Session</h2>
<p>Is similar to this transformer stack:</p>
<pre><code class="lang-haskell"><span class="hljs-type">ReaderT</span> <span class="hljs-type">Connection</span> (<span class="hljs-type">ExceptT</span> <span class="hljs-type">ConnectionError</span> <span class="hljs-type">IO</span>) a</code></pre>
<!-- 
You can think of it as of a such transformer stack. It's different under the hood though.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-41">
    <section class="slide-content">
      <h2 id="session-monad">Session - Monad</h2>
<!-- 

Session is a monad.

It lets you compose sequentially, without caring about the connection

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-42">
    <section class="slide-content">
      <h2 id="session-monad">Session - Monad</h2>
<p>Having</p>
<pre><code class="lang-haskell"><span class="hljs-title">idByTimestamp</span> :: <span class="hljs-type">UTCTime</span> -&gt; <span class="hljs-type">Session</span> <span class="hljs-type">UserId</span>
<span class="hljs-title">nameById</span> :: <span class="hljs-type">UserId</span> -&gt; <span class="hljs-type">Session</span> <span class="hljs-type">Text</span></code></pre>
<p>We can compose</p>
<pre><code class="lang-haskell"><span class="hljs-title">nameByTimestamp</span> :: <span class="hljs-type">UTCTime</span> -&gt; <span class="hljs-type">Session</span> <span class="hljs-type">Text</span>
<span class="hljs-title">nameByTimestamp</span> timestamp =
  idByTimestamp timestamp &gt;&gt;= nameById</code></pre>
<!-- 
  IOW, having two definitions we can combine them into one using the mechanisms provided by a standard abstraction.

  We do not invent anything new here. So there's nothing new to learn for the user of the library.

  Also notice that in this code we don't have to think about the connection or errors. Why? Because we've abstracted over them!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-43">
    <section class="slide-content">
      <h2 id="session-can">Session can</h2>
<ul>
<li><code>Hasql.Session.batch</code> - execute <code>Batch</code></li>
</ul>
<!-- 
It can only do one thing: execute a Batch abstraction
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-44">
    <section class="slide-content">
      <h1 id="batch">Batch</h1>
<!--
And Batch is ..
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-45">
    <section class="slide-content">
      <h2 id="batch-an-abstraction-over-pipelining">Batch - an abstraction over Pipelining</h2>
<!-- 
An abstraction over Pipelining!

Yes you heard me right, that exact pipelining, that libpq lacks.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-46">
    <section class="slide-content">
      <h2 id="batch-an-applicative-functor">Batch - an applicative functor</h2>
<!-- 
Why? What for? Why not a monad then?

Because applicative functors let us compose things parallelly!

And here I'll have to diverge a bit to explain the difference between Applicative and Monad.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-47">
    <section class="slide-content">
      <h2 id="monad-vs-applicative">Monad vs. Applicative</h2>
<!-- 
This is a tough subject. A lot of people struggle to understand it.

I know that becuase I've been there myself.

I think the reason is that people rarely explain the purpose of those abstractions and which problems they solve.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-48">
    <section class="slide-content">
      <h2 id="monad-vs-applicative">Monad vs. Applicative</h2>
<p><code>Monad</code> - sequential composition</p>
<!-- 

Monad is for sequential composition. We get a result of one action and then decide which action to execute afterwards. That's it!

So what kind of composition does the applicative functor do then?

Right!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-49">
    <section class="slide-content">
      <h2 id="monad-vs-applicative">Monad vs. Applicative</h2>
<p><code>Monad</code> - sequential composition</p>
<p><code>Applicative</code> - parallel composition</p>
<!-- 

Parallel!

Now keep this in mind while we go back to pipelining.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-50">
    <section class="slide-content">
      <h2 id="pipelining">Pipelining</h2>
<p><img src="2.png" width="75%" height="75%"/></p>
<!-- 
Take a look: in the second case when the request is issued, the result is still not received.

This means that the second request can not depend on the first one.

This means that we can not use the sequential composition here. But the parallel one will do just fine!

IOW to the left you can see a monad and to the right - an applicative functor.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-51">
    <section class="slide-content">
      <h2 id="batch-an-applicative-functor">Batch - an applicative functor</h2>
<!-- 
And that is why Batch is an applicative functor
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-52">
    <section class="slide-content">
      <h2 id="batch-an-applicative-functor">Batch - an applicative functor</h2>
<p>Having</p>
<pre><code class="lang-haskell"><span class="hljs-title">buyerIdsByProductId</span> :: <span class="hljs-type">ProductId</span> -&gt; <span class="hljs-type">Batch</span> [<span class="hljs-type">BuyerId</span>]
<span class="hljs-title">supplierIdsByProductId</span> :: <span class="hljs-type">ProductId</span> -&gt; <span class="hljs-type">Batch</span> [<span class="hljs-type">SupplierId</span>]</code></pre>
<p>We can compose!</p>
<pre><code class="lang-haskell"><span class="hljs-title">buyerAndSupplierIdsByProductId</span> :: <span class="hljs-type">ProductId</span> -&gt;
                                  <span class="hljs-type">Batch</span> ([<span class="hljs-type">BuyerId</span>], [<span class="hljs-type">SupplierId</span>])
<span class="hljs-title">buyerAndSupplierIdsByProductId</span> productId =
  (,) &lt;$&gt; buyerIdsByProductId productId &lt;*&gt;
          supplierIdsByProductId productId</code></pre>
<!-- 

Take a look. Using a standard abstraction is all it takes to specify that we want to execute two requests using pipelining!

Now imagine the nightmare it would have taken you in C!

And there you go! You get a simple API, yet its not limited in any feature!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-53">
    <section class="slide-content">
      <h2 id="batch-an-applicative-functor">Batch - an applicative functor</h2>
<p>Having</p>
<pre><code class="lang-haskell"><span class="hljs-title">productInfoByProductId</span> :: <span class="hljs-type">ProductId</span> -&gt; <span class="hljs-type">Batch</span> <span class="hljs-type">ProductInfo</span></code></pre>
<p>We get</p>
<pre><code class="lang-haskell"><span class="hljs-title">productInfosByProductIds</span> :: [<span class="hljs-type">ProductId</span>] -&gt; <span class="hljs-type">Batch</span> [<span class="hljs-type">ProductInfo</span>]
<span class="hljs-title">productInfosByProductIds</span> =
  traverse productInfoByProductId</code></pre>
<!-- 
Here's another example. A quite practical one. And picturesque! Using the standard abstraction we get the whole bag of standard combinators for free!

Of course, ideally, it would be better to write a dedicated query in such a case, but having pipelining, it's not that critical.

It's just a little overhead, instead of an exponential difference as it would have been before. 

IOW you can live with that and even deploy that into production.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-54">
    <section class="slide-content">
      <h2 id="batch-can">Batch can</h2>
<ul>
<li><code>Hasql.Batch.statement</code> - execute <code>Statement</code></li>
</ul>
<!-- 
All it can do is execute statements.

Have you noticed that it's the second abstraction that essentially can only do one thing? There'll be more!

A question rises then: why not join them together?

And that's the whole point: this kind of granular isolation is the thing that lets us utilize the standard Haskell abstractions for composition.

As the result of that I don't have to invent my own operations for composition. I just use the standard ones!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-55">
    <section class="slide-content">
      <h1 id="statement">Statement</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-56">
    <section class="slide-content">
      <h2 id="statement-is-an-abstraction-over-">Statement - is an abstraction over ...</h2>
<!-- 
What?
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-57">
    <section class="slide-content">
      <h2 id="statement-is-an-abstraction-over-statement-">Statement - is an abstraction over statement!</h2>
<!-- 
Right! A statement!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-58">
    <section class="slide-content">
      <h2 id="statement-is-defined-as">Statement is defined as</h2>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Statement</span> params result</span></code></pre>
<!-- 
- `params` - контравариантная часть
- `result` - ковариантная часть

Absolutely any database query can be defined using Statement: SELECT, INSERT, CREATE INDEX and etc
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-59">
    <section class="slide-content">
      <h2 id="statement-is-a-profunctor">Statement is a profunctor</h2>

    </section>
  </div>
  <div class="slide hidden" id="slide-60">
    <section class="slide-content">
      <h2 id="statement-is-a-profunctor">Statement is a profunctor</h2>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Statement</span> params result</span></code></pre>
<p>We get:</p>

    </section>
  </div>
  <div class="slide hidden" id="slide-61">
    <section class="slide-content">
      <h2 id="statement-is-a-profunctor">Statement is a profunctor</h2>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Statement</span> params result</span></code></pre>
<p>We get:</p>
<ul>
<li><code>lmap</code> - mapping over <code>params</code></li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-62">
    <section class="slide-content">
      <h2 id="statement-is-a-profunctor">Statement is a profunctor</h2>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Statement</span> params result</span></code></pre>
<p>We get:</p>
<ul>
<li><code>lmap</code> - mapping over <code>params</code></li>
<li><code>rmap</code> - mapping over <code>result</code></li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-63">
    <section class="slide-content">
      <h2 id="statement-is-a-product-of">Statement is a product of</h2>
<ul>
<li>SQL text</li>
</ul>
<!-- 
- SQL text, который мы отсылаем в базу данный
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-64">
    <section class="slide-content">
      <h2 id="statement-is-a-product-of">Statement is a product of</h2>
<ul>
<li>SQL text</li>
<li>Parameters encoder</li>
</ul>
<!-- 
- Спецификация того, как закодировать хаскельные структуры данных
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-65">
    <section class="slide-content">
      <h2 id="statement-is-a-product-of">Statement is a product of</h2>
<ul>
<li>SQL text</li>
<li>Parameters encoder</li>
<li>Results decoder</li>
</ul>
<!-- 
- Спецификация того, как декодировать результаты исполнения
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-66">
    <section class="slide-content">
      <h2 id="statement-can">Statement can</h2>

    </section>
  </div>
  <div class="slide hidden" id="slide-67">
    <section class="slide-content">
      <h2 id="statement-can">Statement can</h2>
<ul>
<li><code>Hasql.Statement.prepared</code> - be prepared</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-68">
    <section class="slide-content">
      <h2 id="statement-can">Statement can</h2>
<ul>
<li><code>Hasql.Statement.prepared</code> - be prepared</li>
<li><code>Hasql.Statement.unprepared</code> - and not :)</li>
</ul>
<!-- 
Для тех, кто не знает prepared statement - это...

Now we're getting to the bottom of this. Actually we have a few more layers of abstractions coming, but we'll talk about them later. It's time for code now!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-69">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-70">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-71">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult
  <span class="hljs-keyword">where</span>
    sql =
      <span class="hljs-string">"SELECT name, birthday \
      \FROM persons \
      \WHERE surname = $1 AND birthday &gt; $2"</span></code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-72">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult
  <span class="hljs-keyword">where</span>
    sql =
      <span class="hljs-string">"SELECT name, birthday \
      \FROM persons \
      \WHERE surname = $1 AND birthday &gt; $2"</span>
    encodeParams =
      contrazip2 surname birthday</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-73">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult
  <span class="hljs-keyword">where</span>
    sql =
      <span class="hljs-string">"SELECT name, birthday \
      \FROM persons \
      \WHERE surname = $1 AND birthday &gt; $2"</span>
    encodeParams =
      contrazip2 surname birthday
      <span class="hljs-keyword">where</span>
        surname =
          <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.text)
        birthday =
          <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.date)</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-74">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult
  <span class="hljs-keyword">where</span>
    sql =
      <span class="hljs-string">"SELECT name, birthday \
      \FROM persons \
      \WHERE surname = $1 AND birthday &gt; $2"</span>
    encodeParams =
      contrazip2 surname birthday
      <span class="hljs-keyword">where</span>
        surname =
          <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.text)
        birthday =
          <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.date)
    decodeResult =
      <span class="hljs-type">DecodeResult</span>.foldRows <span class="hljs-type">Foldl</span>.vector decodeRow</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-75">
    <section class="slide-content">
      <h2 id="statement-example">Statement example</h2>
<pre><code class="lang-haskell"><span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> ∷ <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>)
                                              (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">nameAndBirthdayBySurnameAfterDay</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult
  <span class="hljs-keyword">where</span>
    sql =
      <span class="hljs-string">"SELECT name, birthday \
      \FROM persons \
      \WHERE surname = $1 AND birthday &gt; $2"</span>
    encodeParams =
      contrazip2 surname birthday
      <span class="hljs-keyword">where</span>
        surname =
          <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.text)
        birthday =
          <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.date)
    decodeResult =
      <span class="hljs-type">DecodeResult</span>.foldRows <span class="hljs-type">Foldl</span>.vector decodeRow
      <span class="hljs-keyword">where</span>
        decodeRow =
          (,) &lt;$&gt; <span class="hljs-type">DecodeRow</span>.primitive <span class="hljs-type">DecodePrimitive</span>.text &lt;*&gt;
                  <span class="hljs-type">DecodeRow</span>.primitive <span class="hljs-type">DecodePrimitive</span>.date</code></pre>
<!-- 

Я рекомендую стейтменты объявлять вот так монолитно вместе кодеками. Это сбережёт вас от проблем рефакторинга. Например, когда в SQL поменяете название поля, это напомнит вам обратить внимание и на кодеки.

Далее кратко перечислю оставшиеся абстракции. Так как принцип компонования везде один.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-76">
    <section class="slide-content">
      <h2 id="encoders">Encoders</h2>
<ul>
<li><code>EncodeParams</code> - Divisible</li>
<li><code>EncodeParam</code> - Contravariant</li>
<li><code>EncodePrimitive</code> - Contravariant</li>
<li><code>EncodeArray</code> (<em>in the works</em>) - Contravariant</li>
<li><code>EncodeComposite</code> (<em>in the works</em>) - Contravariant</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-77">
    <section class="slide-content">
      <h2 id="decoders">Decoders</h2>
<ul>
<li><code>DecodeResult</code> - Functor</li>
<li><code>DecodeRow</code> - Applicative</li>
<li><code>DecodePrimitive</code> - Functor</li>
<li><code>DecodeArray</code> (<em>in the works</em>) - Functor</li>
<li><code>DecodeComposite</code> (<em>in the works</em>) - Functor</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-78">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>IO</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-79">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>IO &lt;- Session</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-80">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>IO &lt;- Session &lt;- Batch</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-81">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>IO &lt;- Session &lt;- Batch &lt;- Statement</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-82">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>                                       (SQL,
IO &lt;- Session &lt;- Batch &lt;- Statement &lt;-  EncodeParams,
                                        DecodeResult)</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-83">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>                                       (SQL,
IO &lt;- Session &lt;- Batch &lt;- Statement &lt;-  EncodeParams,
                                        DecodeResult)</code></pre>
<pre><code>EncodeParams &lt;- (EncodePrimitive | EncodeArray | EncodeComposite)</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-84">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>                                       (SQL,
IO &lt;- Session &lt;- Batch &lt;- Statement &lt;-  EncodeParams,
                                        DecodeResult)</code></pre>
<pre><code>EncodeParams &lt;- (EncodePrimitive | EncodeArray | EncodeComposite)</code></pre>
<pre><code>EncodeArray &lt;- (EncodePrimitive | EncodeArray | EncodeComposite)</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-85">
    <section class="slide-content">
      <h2 id="dependency-graph">Dependency graph</h2>
<pre><code>                                       (SQL,
IO &lt;- Session &lt;- Batch &lt;- Statement &lt;-  EncodeParams,
                                        DecodeResult)</code></pre>
<pre><code>EncodeParams &lt;- (EncodePrimitive | EncodeArray | EncodeComposite)</code></pre>
<pre><code>EncodeArray &lt;- (EncodePrimitive | EncodeArray | EncodeComposite)</code></pre>
<pre><code>DecodeResult &lt;- DecodeRow &lt;- (DecodePrimitive | DecodeArray | DecodeComposite)</code></pre>
<!--
Ну, и так далее.

Короче я могу долго всё детально расписывать, но, я думаю, принцип уже ясен. Как в конструкторе Лего одно собирается из другого.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-86">
    <section class="slide-content">
      <h1 id="api-peculiarities">API peculiarities</h1>
<!-- 
Поговорим об особенностях такого API.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-87">
    <section class="slide-content">
      <h2 id="api-peculiarities">API peculiarities</h2>
<ul>
<li>Every aspect gets an abstraction</li>
</ul>
<!-- 
Каждый аспект во всей проблематике представлен изолированной абстракцией
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-88">
    <section class="slide-content">
      <h2 id="api-peculiarities">API peculiarities</h2>
<ul>
<li>Every aspect gets an abstraction</li>
<li>Each abstraction is very simple</li>
</ul>
<!-- 
Each abstraction is very simple in the sense of what it can do.

Simplicity helps a lot to focus on your task!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-89">
    <section class="slide-content">
      <h2 id="api-peculiarities">API peculiarities</h2>
<ul>
<li>Every aspect gets an abstraction</li>
<li>Each abstraction is very simple</li>
<li>Everything is tied to category theory</li>
</ul>
<!-- 
Каждая абстракция является какой-либо категорией: монада, апликативный функтор, контравариантный функтор, профунктор, ковариантный функтор

Раз тут столько соответствий с Теорией категорий, значит что-то в этом должно быть верно!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-90">
    <section class="slide-content">
      <h2 id="api-peculiarities">API peculiarities</h2>
<ul>
<li>Every aspect gets an abstraction</li>
<li>Each abstraction is very simple</li>
<li>Everything is tied to category theory</li>
<li>No custom combinators</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-91">
    <section class="slide-content">
      <h2 id="api-peculiarities">API peculiarities</h2>
<ul>
<li>Every aspect gets an abstraction</li>
<li>Each abstraction is very simple</li>
<li>Everything is tied to category theory</li>
<li>No custom combinators</li>
<li>No custom typeclasses</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-92">
    <section class="slide-content">
      <h1 id="epiphany">Epiphany</h1>
<!-- 

Работая над всем этим я прозрел! Может быть, помогу прозреть кому-то из вас.

Рецепт качественного API лежит на поверхности и, на самом деле, крайне прост. Но, почему-то, никто об этом не говорит. Я и сам вот так чётко сформулировать следующую мысль смог только, готовясь к этой презентации.

Итак,
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-93">
    <section class="slide-content">
      <h2 id="problem-division">Problem division</h2>
<!-- 
Любое API, какое не возьмите, is a product of двух категорий проблем. Всего двух!! 
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-94">
    <section class="slide-content">
      <h2 id="problem-division">Problem division</h2>
<ul>
<li>Domain problem</li>
</ul>
<!-- 
То, собственно, чему посвящён ваш проект.

Например, если он посвящён стримингу, то это чтение/запись файлов, запуск парсеров/кодеков, работа с сетью и тд.

В случае с Hasql, это работа с соединением, мэппинг данных, сотню раз упомянутый пайплайнинг.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-95">
    <section class="slide-content">
      <h2 id="problem-division">Problem division</h2>
<ul>
<li>Domain problem</li>
<li>Combination problem</li>
</ul>
<!-- 
Это когда берём разные куски, сочленяем их как-то по-интересному.

Я предполагаю (и ещё не втречал тому опровержения), что абстракций теории категорий достаточно для решения всего спектра проблем композиции. А значит, не надо новых!

Так и на деле, в Hasql нет ни единой функции, которая бы занималась композицией. Все функции доменные! А композиция решается за счёт стандартных абстракций из теории категорий.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-96">
    <section class="slide-content">
      <h2 id="a-recipe">A recipe</h2>
<p>A project should only cover the domain problem</p>
<!-- 
А комбинирование осуществлять за счёт Теории категорий.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-97">
    <section class="slide-content">
      <h1 id="transaction">Transaction</h1>
<!-- 
Абстракция над транзакциями с базой данных, которая автоматически откатывается и переexecutesся в случае кофликтов, которая является монадой, и в целом ведёт себя, как гениальная абстракция STM.

Сюрприз, сюрприз! Она встраивается в упомянутый граф идеально!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-98">
    <section class="slide-content">
      <h2 id="transaction">Transaction</h2>
<pre><code>IO &lt;- Session &lt;- Batch &lt;- Statement</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-99">
    <section class="slide-content">
      <h2 id="transaction">Transaction</h2>
<pre><code>IO &lt;- Session &lt;- Batch &lt;- Statement</code></pre>
<ul>
<li><code>Transaction</code> executes <code>Batch</code></li>
<li><code>Session</code> executes <code>Transaction</code></li>
</ul>
<!-- 
То есть, транзакция executesся абстракцией над соединением. Вы же не можете исполнить одну транзакцию на нескольких соединениях. Логично? Логично!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-100">
    <section class="slide-content">
      <h2 id="transaction">Transaction</h2>
<pre><code>IO &lt;- Session &lt;- Batch &lt;- Statement</code></pre>
<ul>
<li><code>Transaction</code> executes <code>Batch</code></li>
<li><code>Session</code> executes <code>Transaction</code></li>
</ul>
<!-- 
То есть, транзакция executesся абстракцией над соединением. Вы же не можете исполнить одну транзакцию на нескольких соединениях. Логично? Логично!
 -->

<pre><code>IO &lt;- Session &lt;- Transaction &lt;- Batch &lt;- Statement
         ^_______________________/</code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-101">
    <section class="slide-content">
      <h1 id="project-status">Project status</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-102">
    <section class="slide-content">
      <h1 id="project-status">Project status</h1>
<ul>
<li>Stable version is battle-tested!</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-103">
    <section class="slide-content">
      <h1 id="project-status">Project status</h1>
<ul>
<li>Stable version is battle-tested!</li>
<li>Stable version already is the fastest Haskell driver</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-104">
    <section class="slide-content">
      <h1 id="project-status">Project status</h1>
<ul>
<li>Stable version is battle-tested!</li>
<li>Stable version already is the fastest Haskell driver</li>
<li>A lot of active users</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-105">
    <section class="slide-content">
      <h1 id="project-status">Project status</h1>
<ul>
<li>Stable version is battle-tested!</li>
<li>Stable version already is the fastest Haskell driver</li>
<li>A lot of active users</li>
<li>Above 200 stars on GitHub</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-106">
    <section class="slide-content">
      <h1 id="project-status">Project status</h1>
<ul>
<li>Stable version is battle-tested!</li>
<li>Stable version already is the fastest Haskell driver</li>
<li>A lot of active users</li>
<li>Above 200 stars on GitHub</li>
<li>Stands behind Postgrest, which has 10k stars on GitHub</li>
</ul>

    </section>
  </div>
  <div class="slide hidden author-slide" id="slide-107">
    <section class="slide-content">
      <div class="author">
  <h1 class="name">Nikita Volkov</h1>
    <h3 class="twitter">
      <a href="http://twitter.com/@NikitaYVolkov">@NikitaYVolkov</a>
    </h3>
    <h3 class="url">
      <a href="http://nikita-volkov.github.io">http://nikita-volkov.github.io</a>
    </h3>
    <h3 class="email">
      <a href="mailto:nikita@metrix.ai">nikita@metrix.ai</a>
    </h3>
</div>

    </section>
  </div>


  <script type="text/javascript">
    /**
 * Returns the current page number of the presentation.
 */
function currentPosition() {
  return parseInt(document.querySelector('.slide:not(.hidden)').id.slice(6));
}


/**
 * Navigates forward n pages
 * If n is negative, we will navigate in reverse
 */
function navigate(n) {
  var position = currentPosition();
  var numSlides = document.getElementsByClassName('slide').length;

  /* Positions are 1-indexed, so we need to add and subtract 1 */
  var nextPosition = (position - 1 + n) % numSlides + 1;

  /* Normalize nextPosition in-case of a negative modulo result */
  nextPosition = (nextPosition - 1 + numSlides) % numSlides + 1;

  document.getElementById('slide-' + position).classList.add('hidden');
  document.getElementById('slide-' + nextPosition).classList.remove('hidden');

  updateProgress();
  updateURL();
  updateTabIndex();
}


/**
 * Updates the current URL to include a hashtag of the current page number.
 */
function updateURL() {
  window.history.replaceState({} , null, '#' + currentPosition());
}


/**
 * Sets the progress indicator.
 */
function updateProgress() {
  var progressBar = document.querySelector('.progress-bar');

  if (progressBar !== null) {
    var numSlides = document.getElementsByClassName('slide').length;
    var position = currentPosition() - 1;
    var percent = (numSlides === 1) ? 100 : 100 * position / (numSlides - 1);
    progressBar.style.width = percent.toString() + '%';
  }
}


/**
 * Removes tabindex property from all links on the current slide, sets
 * tabindex = -1 for all links on other slides. Prevents slides from appearing
 * out of control.
 */
function updateTabIndex() {
  var allLinks = document.querySelectorAll('.slide a');
  var position = currentPosition();
  var currentPageLinks = document.getElementById('slide-' + position).querySelectorAll('a');
  var i;

  for (i = 0; i < allLinks.length; i++) {
    allLinks[i].setAttribute('tabindex', -1);
  }

  for (i = 0; i < currentPageLinks.length; i++) {
    currentPageLinks[i].removeAttribute('tabindex');
  }
}

/**
 * Determines whether or not we are currently in full screen mode
 */
function isFullScreen() {
  return document.fullscreenElement ||
         document.mozFullScreenElement ||
         document.webkitFullscreenElement ||
         document.msFullscreenElement;
}

/**
 * Toggle fullScreen mode on document element.
 * Works on chrome (>= 15), firefox (>= 9), ie (>= 11), opera(>= 12.1), safari (>= 5).
 */
function toggleFullScreen() {
  /* Convenient renames */
  var docElem = document.documentElement;
  var doc = document;

  docElem.requestFullscreen =
      docElem.requestFullscreen ||
      docElem.msRequestFullscreen ||
      docElem.mozRequestFullScreen ||
      docElem.webkitRequestFullscreen.bind(docElem, Element.ALLOW_KEYBOARD_INPUT);

  doc.exitFullscreen =
      doc.exitFullscreen ||
      doc.msExitFullscreen ||
      doc.mozCancelFullScreen ||
      doc.webkitExitFullscreen;

  isFullScreen() ? doc.exitFullscreen() : docElem.requestFullscreen();
}

document.addEventListener('DOMContentLoaded', function () {
  // Update the tabindex to prevent weird slide transitioning
  updateTabIndex();

  // If the location hash specifies a page number, go to it.
  var page = window.location.hash.slice(1);
  if (page) {
    navigate(parseInt(page) - 1);
  }

  document.onkeydown = function (e) {
    var kc = e.keyCode;

    // left, down, H, J, backspace, PgUp - BACK
    // up, right, K, L, space, PgDn - FORWARD
    // enter - FULLSCREEN
    if (kc === 37 || kc === 40 || kc === 8 || kc === 72 || kc === 74 || kc === 33) {
      navigate(-1);
    } else if (kc === 38 || kc === 39 || kc === 32 || kc === 75 || kc === 76 || kc === 34) {
      navigate(1);
    } else if (kc === 13) {
      toggleFullScreen();
    }
  };

  if (document.querySelector('.next') && document.querySelector('.prev')) {
    document.querySelector('.next').onclick = function (e) {
      e.preventDefault();
      navigate(1);
    };

    document.querySelector('.prev').onclick = function (e) {
      e.preventDefault();
      navigate(-1);
    };
  }
});
  </script>
</body>
</html>